// NeuronEvolution.usf
// NEBULA EMERGENT GPU Compute Shader - Real Implementation

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"

// Physical constants
#define PLANCK_CONSTANT 6.62607015e-34
#define BOLTZMANN_CONSTANT 1.380649e-23
#define SPEED_OF_LIGHT 299792458.0
#define GRAVITATIONAL_CONSTANT 6.67430e-11

// Thread group configuration
#define THREADGROUP_SIZE 256

// Neuron state structure
struct FNeuronState
{
    float3 Position;
    float3 Velocity;
    float Mass;
    float Luminosity;
    float4 Spectrum;  // RGBA wavelength intensities
    float Activation;
    float Potential;
    float Energy;
    float RefractoryTimer;
    int ClusterID;
    float Age;
    float Temperature;
};

// Photon structure
struct FPhoton
{
    float3 Position;
    float3 Direction;
    float Energy;
    float Wavelength;
    int Active;
    int SourceNeuronID;
};

// Buffers
RWStructuredBuffer<FNeuronState> NeuronBuffer;
RWStructuredBuffer<FPhoton> PhotonBuffer;
RWStructuredBuffer<float4> ConnectionMatrix;  // Sparse connection weights
RWBuffer<uint> ClusterBuffer;

// Parameters
uint NumNeurons;
uint NumPhotons;
float DeltaTime;
float Temperature;
float FusionThreshold;
float FissionThreshold;
float3 GalaxyCenter;
float GalaxyRadius;

// ============================================================================
// Neuron Activation Function - Based on Hodgkin-Huxley Model
// ============================================================================

float CalculateActivation(float Potential, float Temperature)
{
    // Hodgkin-Huxley inspired activation
    float V = Potential;
    float T = Temperature;
    
    // Sodium channel activation
    float alpha_m = 0.1 * (V + 40.0) / (1.0 - exp(-(V + 40.0) / 10.0));
    float beta_m = 4.0 * exp(-(V + 65.0) / 18.0);
    float m = alpha_m / (alpha_m + beta_m);
    
    // Potassium channel activation
    float alpha_n = 0.01 * (V + 55.0) / (1.0 - exp(-(V + 55.0) / 10.0));
    float beta_n = 0.125 * exp(-(V + 65.0) / 80.0);
    float n = alpha_n / (alpha_n + beta_n);
    
    // Temperature modulation
    float Q10 = 3.0;  // Temperature coefficient
    float tempFactor = pow(Q10, (T - 6.3) / 10.0);
    
    // Final activation
    return saturate(m * m * m * n * tempFactor);
}

// ============================================================================
// Photon-Neuron Interaction
// ============================================================================

void ProcessPhotonAbsorption(uint NeuronID, uint PhotonID)
{
    FNeuronState neuron = NeuronBuffer[NeuronID];
    FPhoton photon = PhotonBuffer[PhotonID];
    
    if (!photon.Active)
        return;
    
    // Distance check
    float3 delta = photon.Position - neuron.Position;
    float distSq = dot(delta, delta);
    float radius = pow(neuron.Mass, 0.8) * 0.5;  // Schwarzschild-like radius
    
    if (distSq < radius * radius)
    {
        // Absorption cross-section (wavelength dependent)
        float crossSection = 1e-20 * exp(-abs(photon.Wavelength - 550e-9) / 100e-9);
        
        // Probabilistic absorption
        float absorptionProb = 1.0 - exp(-crossSection * neuron.Mass);
        
        // Use Wang hash for pseudo-random
        uint hash = WangHash(NeuronID * 1000 + PhotonID);
        float rand = float(hash) / float(0xFFFFFFFF);
        
        if (rand < absorptionProb)
        {
            // Energy transfer
            float energyTransfer = photon.Energy;
            
            // Update neuron potential (voltage)
            neuron.Potential += energyTransfer / (BOLTZMANN_CONSTANT * neuron.Temperature);
            
            // Update spectrum based on absorbed wavelength
            float spectrumIndex = (photon.Wavelength - 400e-9) / (300e-9) * 4.0;
            int idx = clamp(int(spectrumIndex), 0, 3);
            neuron.Spectrum[idx] += 0.1;
            neuron.Spectrum = normalize(neuron.Spectrum);
            
            // Increase temperature (thermalization)
            neuron.Temperature += energyTransfer / (neuron.Mass * 1e3);
            
            // Mark photon as absorbed
            PhotonBuffer[PhotonID].Active = 0;
            
            // Write back
            NeuronBuffer[NeuronID] = neuron;
        }
    }
}

// ============================================================================
// Fusion Detection and Processing
// ============================================================================

groupshared uint gs_FusionPairs[THREADGROUP_SIZE * 2];
groupshared uint gs_NumFusionPairs;

void DetectFusion(uint NeuronID)
{
    FNeuronState neuron = NeuronBuffer[NeuronID];
    
    // High energy state required for fusion
    if (neuron.Energy < FusionThreshold)
        return;
    
    // Search nearby neurons
    for (uint other = 0; other < NumNeurons; other++)
    {
        if (other == NeuronID)
            continue;
            
        FNeuronState otherNeuron = NeuronBuffer[other];
        
        float3 delta = otherNeuron.Position - neuron.Position;
        float dist = length(delta);
        
        // Critical distance for fusion (based on combined mass)
        float criticalDist = pow(neuron.Mass + otherNeuron.Mass, 0.33) * 2.0;
        
        if (dist < criticalDist)
        {
            // Energy condition (both must be energetic)
            if (otherNeuron.Energy > FusionThreshold * 0.8)
            {
                // Prevent double-counting (only lower ID initiates)
                if (NeuronID < other)
                {
                    uint pairIndex;
                    InterlockedAdd(gs_NumFusionPairs, 1, pairIndex);
                    
                    if (pairIndex < THREADGROUP_SIZE)
                    {
                        gs_FusionPairs[pairIndex * 2] = NeuronID;
                        gs_FusionPairs[pairIndex * 2 + 1] = other;
                    }
                }
            }
        }
    }
}

void ProcessFusion(uint PairIndex)
{
    if (PairIndex >= gs_NumFusionPairs)
        return;
        
    uint ID1 = gs_FusionPairs[PairIndex * 2];
    uint ID2 = gs_FusionPairs[PairIndex * 2 + 1];
    
    FNeuronState n1 = NeuronBuffer[ID1];
    FNeuronState n2 = NeuronBuffer[ID2];
    
    // Conservation laws
    float totalMass = n1.Mass + n2.Mass;
    float3 totalMomentum = n1.Velocity * n1.Mass + n2.Velocity * n2.Mass;
    float totalEnergy = n1.Energy + n2.Energy;
    
    // Fused neuron properties
    FNeuronState fused;
    fused.Mass = totalMass;
    fused.Position = (n1.Position * n1.Mass + n2.Position * n2.Mass) / totalMass;
    fused.Velocity = totalMomentum / totalMass;
    
    // Energy release (mass defect)
    float bindingEnergy = 0.1 * totalMass;  // E=mcÂ² inspired
    fused.Energy = totalEnergy + bindingEnergy;
    fused.Luminosity = n1.Luminosity + n2.Luminosity + bindingEnergy * 10.0;
    
    // Spectrum combination (weighted average)
    fused.Spectrum = (n1.Spectrum * n1.Mass + n2.Spectrum * n2.Mass) / totalMass;
    
    // Neural properties
    fused.Activation = max(n1.Activation, n2.Activation);
    fused.Potential = (n1.Potential + n2.Potential) * 0.5;
    fused.Temperature = (n1.Temperature * n1.Mass + n2.Temperature * n2.Mass) / totalMass;
    
    // Cluster inheritance
    fused.ClusterID = (n1.ClusterID == n2.ClusterID) ? n1.ClusterID : -1;
    
    // Write fused neuron to first position, deactivate second
    NeuronBuffer[ID1] = fused;
    NeuronBuffer[ID2].Energy = 0;  // Mark for removal
}

// ============================================================================
// Fission Processing
// ============================================================================

void ProcessFission(uint NeuronID)
{
    FNeuronState neuron = NeuronBuffer[NeuronID];
    
    if (neuron.Energy > FissionThreshold)
        return;
        
    // Low energy causes splitting
    if (neuron.Mass > 1.0)  // Can only split if massive enough
    {
        // Create two daughter neurons
        FNeuronState daughter1 = neuron;
        FNeuronState daughter2 = neuron;
        
        // Mass distribution (asymmetric for variety)
        float ratio = 0.4 + 0.2 * sin(neuron.Age * 100.0);
        daughter1.Mass = neuron.Mass * ratio;
        daughter2.Mass = neuron.Mass * (1.0 - ratio);
        
        // Position separation
        float3 separation = normalize(float3(
            sin(neuron.Age * 17.0),
            cos(neuron.Age * 23.0),
            sin(neuron.Age * 31.0)
        )) * 5.0;
        
        daughter1.Position = neuron.Position + separation;
        daughter2.Position = neuron.Position - separation;
        
        // Velocity perturbation (conservation of momentum)
        float3 kick = separation * 0.1;
        daughter1.Velocity = neuron.Velocity + kick / daughter1.Mass;
        daughter2.Velocity = neuron.Velocity - kick / daughter2.Mass;
        
        // Energy distribution
        daughter1.Energy = neuron.Energy * 0.6;
        daughter2.Energy = neuron.Energy * 0.6;  // Some energy lost
        
        // Neural reset
        daughter1.Potential = 0;
        daughter1.Activation = 0;
        daughter2.Potential = 0;
        daughter2.Activation = 0;
        
        // Write back (daughter2 goes to a reserved slot)
        NeuronBuffer[NeuronID] = daughter1;
        // Note: In real implementation, need dynamic allocation for daughter2
    }
}

// ============================================================================
// Main Compute Kernel
// ============================================================================

[numthreads(THREADGROUP_SIZE, 1, 1)]
void MainCS(
    uint3 GroupId : SV_GroupID,
    uint3 DispatchThreadId : SV_DispatchThreadID,
    uint3 GroupThreadId : SV_GroupThreadID,
    uint GroupIndex : SV_GroupIndex)
{
    uint NeuronID = DispatchThreadId.x;
    
    if (NeuronID >= NumNeurons)
        return;
    
    // Initialize group shared memory
    if (GroupIndex == 0)
    {
        gs_NumFusionPairs = 0;
    }
    GroupMemoryBarrierWithGroupSync();
    
    // Load neuron state
    FNeuronState neuron = NeuronBuffer[NeuronID];
    
    // Skip dead neurons
    if (neuron.Energy <= 0)
        return;
    
    // ========== Phase 1: Gravitational Evolution ==========
    
    float3 gravForce = float3(0, 0, 0);
    
    // N-body gravitation (simplified with cutoff)
    [unroll(32)]  // Process first 32 neighbors
    for (uint i = 0; i < min(32, NumNeurons); i++)
    {
        if (i == NeuronID)
            continue;
            
        FNeuronState other = NeuronBuffer[i];
        float3 delta = other.Position - neuron.Position;
        float distSq = dot(delta, delta) + 0.01;  // Softening
        
        if (distSq < GalaxyRadius * GalaxyRadius)
        {
            float forceMag = GRAVITATIONAL_CONSTANT * neuron.Mass * other.Mass / distSq;
            gravForce += normalize(delta) * forceMag;
        }
    }
    
    // Galaxy rotation (differential)
    float r = length(neuron.Position.xy);
    float angularVel = 0.01 * (1.0 + 100.0 / (r + 100.0));
    float3 rotationForce = float3(
        -neuron.Position.y * angularVel * angularVel,
        neuron.Position.x * angularVel * angularVel,
        0
    );
    
    gravForce += rotationForce * neuron.Mass;
    
    // Update velocity and position
    neuron.Velocity += gravForce / neuron.Mass * DeltaTime;
    neuron.Position += neuron.Velocity * DeltaTime;
    
    // ========== Phase 2: Photon Interactions ==========
    
    // Process photon absorption
    [unroll(16)]
    for (uint p = 0; p < min(16, NumPhotons); p++)
    {
        uint PhotonID = (NeuronID * 16 + p) % NumPhotons;
        ProcessPhotonAbsorption(NeuronID, PhotonID);
    }
    
    // ========== Phase 3: Neural Dynamics ==========
    
    // Update activation based on potential
    float newActivation = CalculateActivation(neuron.Potential, neuron.Temperature);
    
    // Refractory period
    if (neuron.RefractoryTimer > 0)
    {
        neuron.RefractoryTimer -= DeltaTime;
        newActivation = 0;
    }
    
    // Fire if threshold exceeded
    if (newActivation > 0.8 && neuron.RefractoryTimer <= 0)
    {
        // Emit photons (handled in separate pass)
        neuron.Luminosity *= 2.0;  // Burst
        neuron.RefractoryTimer = 0.01;  // 10ms refractory
        
        // Synaptic transmission (simplified)
        for (uint conn = 0; conn < 8; conn++)
        {
            uint targetID = WangHash(NeuronID * 8 + conn) % NumNeurons;
            float weight = ConnectionMatrix[NeuronID * 8 + conn].x;
            
            if (weight > 0)
            {
                // Transmit signal
                InterlockedAdd(NeuronBuffer[targetID].Potential, 
                              uint(newActivation * weight * 1000.0));
            }
        }
    }
    
    neuron.Activation = newActivation;
    
    // ========== Phase 4: Energy Metabolism ==========
    
    // Energy consumption
    neuron.Energy -= (neuron.Luminosity * 0.001 + neuron.Activation * 0.01) * DeltaTime;
    
    // Temperature regulation
    neuron.Temperature += (neuron.Activation * 10.0 - (neuron.Temperature - 300.0) * 0.1) * DeltaTime;
    
    // Decay
    neuron.Potential *= exp(-DeltaTime / 1.0);  // 1 second decay
    neuron.Luminosity = max(neuron.Luminosity * 0.99, 0.1);
    
    // Age
    neuron.Age += DeltaTime;
    
    // ========== Phase 5: Fusion/Fission Detection ==========
    
    GroupMemoryBarrierWithGroupSync();
    
    DetectFusion(NeuronID);
    
    GroupMemoryBarrierWithGroupSync();
    
    // Process fusion pairs
    if (GroupIndex < gs_NumFusionPairs)
    {
        ProcessFusion(GroupIndex);
    }
    
    // Check for fission
    ProcessFission(NeuronID);
    
    // ========== Phase 6: Write Back ==========
    
    NeuronBuffer[NeuronID] = neuron;
}

// ============================================================================
// Photon Emission Kernel
// ============================================================================

[numthreads(THREADGROUP_SIZE, 1, 1)]
void PhotonEmissionCS(
    uint3 DispatchThreadId : SV_DispatchThreadID)
{
    uint NeuronID = DispatchThreadId.x;
    
    if (NeuronID >= NumNeurons)
        return;
        
    FNeuronState neuron = NeuronBuffer[NeuronID];
    
    // Emit photons based on luminosity
    uint numPhotonsToEmit = uint(neuron.Luminosity * 10.0);
    
    for (uint i = 0; i < numPhotonsToEmit; i++)
    {
        uint PhotonID = (NeuronID * 100 + i) % NumPhotons;
        
        FPhoton photon;
        photon.Position = neuron.Position;
        
        // Random direction (using hash for determinism)
        uint hash = WangHash(NeuronID * 1000 + i + uint(neuron.Age * 1000));
        float theta = float(hash & 0xFFFF) / 65535.0 * 6.28318;
        float phi = float((hash >> 16) & 0xFFFF) / 65535.0 * 3.14159;
        
        photon.Direction = float3(
            sin(phi) * cos(theta),
            sin(phi) * sin(theta),
            cos(phi)
        );
        
        // Wavelength based on spectrum
        float spectrumSample = float(i % 4) / 3.0;
        photon.Wavelength = 400e-9 + spectrumSample * 300e-9;
        
        // Energy based on temperature (Planck's law simplified)
        photon.Energy = PLANCK_CONSTANT * SPEED_OF_LIGHT / photon.Wavelength;
        photon.Energy *= neuron.Temperature / 5000.0;  // Normalized to 5000K
        
        photon.Active = 1;
        photon.SourceNeuronID = NeuronID;
        
        PhotonBuffer[PhotonID] = photon;
    }
}